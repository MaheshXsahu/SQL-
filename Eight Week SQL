# Restaurant Project

**üçú Danny's Diner**

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/45353fc0-e537-43b5-8a3e-05d1baa26264/b4e4d206-638c-408e-bcb7-0e6942a25826/image.png)

**üìö Table of Contents**

- Introduction
- Business Task
- Entity Relationship Diagram
- Business Question and Solution

# **Introduction:**

Danny seriously loves Japanese food so in the beginning of 2024, he decides to embark upon a risky venture and opens up a cute little restaurant that sells his 3 favourite foods: sushi, curry and ramen. Danny‚Äôs Diner is in need of your assistance to help the restaurant stay afloat - the restaurant has captured some very basic data from their few months of operation but have no idea how to use their data to help them run the business.

# Business Task And Problem Statement :

Danny wants to use the data to answer a few simple questions about his customers, especially about their visiting patterns, how much money they‚Äôve spent and also which menu items are their favourite. Having this deeper connection with his customers will help him deliver a better and more personalised experience for his loyal customers.

He plans on using these insights to help him decide whether he should expand the existing customer loyalty program - additionally he needs help to generate some basic datasets so his team can easily inspect the data without needing to use SQL.

Danny has provided you with a sample of his overall customer data due to privacy issues - but he hopes that these examples are enough for you to write fully functioning SQL queries to help him answer his questions!

**Danny has shared with you 3 key datasets for this case study:**

- `sales`
- `menu`
- `members`

You can inspect the entity relationship diagram and example data below.

# **Entity Relationship Diagram:**

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/45353fc0-e537-43b5-8a3e-05d1baa26264/d92b5e5a-1014-4b2a-a2eb-bfb3edce2ea5/image.png)

### **Table 1:   sales**

The¬†`sales`¬†table captures all¬†`customer_id`¬†level purchases with an corresponding¬†`order_date`¬†and¬†`product_id`¬†information for when and what menu items were ordered.

| **customer_id** | **order_date** | **product_id** |
| --- | --- | --- |
| A | 2021-01-01 | 1 |
| A | 2021-01-01 | 2 |
| A | 2021-01-07 | 2 |
| A | 2021-01-10 | 3 |
| A | 2021-01-11 | 3 |
| A | 2021-01-11 | 3 |
| B | 2021-01-01 | 2 |
| B | 2021-01-02 | 2 |
| B | 2021-01-04 | 1 |
| B | 2021-01-11 | 1 |
| B | 2021-01-16 | 3 |
| B | 2021-02-01 | 3 |
| C | 2021-01-01 | 3 |
| C | 2021-01-01 | 3 |
| C | 2021-01-07 | 3 |

### **Table 2:   menu**

The¬†`menu`¬†table maps the¬†`product_id`¬†to the actual¬†`product_name`¬†and¬†`price`¬†of each menu item.

| **product_id** | **product_name** | **price** |
| --- | --- | --- |
| 1 | sushi | 10 |
| 2 | curry | 15 |
| 3 | ramen | 12 |

### **Table 3:   members**

The final¬†`members`¬†table captures the¬†`join_date`¬†when a¬†`customer_id`¬†joined the beta version of the Danny‚Äôs Diner loyalty program.

| **customer_id** | **join_date** |
| --- | --- |
| A | 2021-01-07 |
| B | 2021-01-09 |

# Business Question and Solution

### **Each of the following case study questions can be answered using a single SQL statement:**

1. What is the total amount each customer spent at the restaurant?
2. How many days has each customer visited the restaurant?
3. What was the first item from the menu purchased by each customer?
4. What is the most purchased item on the menu and how many times was it purchased by all customers?
5. Which item was the most popular for each customer?
6. Which item was purchased first by the customer after they became a member?
7. Which item was purchased just before the customer became a member?
8. What is the total items and amount spent for each member before they became a member?
9. If each $1 spent equates to 10 points and sushi has a 2x points multiplier - how many points would each customer have?
10. In the first week after a customer joins the program (including their join date) they earn 2x points on all items, not just sushi - how many points do customer A and B have at the end of January?

### **Solution :**

*(I am using PostgreSQL for all the query)*

1. **What is the total amount each customer spent at the restaurant?**
    
    ```sql
    **SELECT
    	sales.customer_id,
    	SUM(menu.price) AS total_spent($)
    FROM dannys_diner.sales
    	INNER JOIN dannys_diner.menu
    	ON sales.product_id = menu.product_id
    GROUP BY sales.customer_id
    ORDER BY sales.customer_id ASC;**
    ```
    
    **Output:**
    
    | customer_id | total_spent**($)** |
    | --- | --- |
    | A | 76 |
    | B | 74 |
    | C | 36 |
    
    **Here's a breakdown of the SQL query:**
    
    *1. **Selecting Data:***
    
    - `*sales.customer_id`: This selects the customer ID from the `sales` table.*
    - `*SUM(menu.price) AS total_spent*`**($)***: This calculates the sum of `menu.price` and assigns it an alias `total_sales`.*
    
    ***2. Joining Tables:***
    
    - `*FROM dannys_diner.sales`: Specifies the `sales` table as the source for data.*
    - `*INNER JOIN dannys_diner.menu`: Performs an inner join between `sales` and `menu` tables.*
    
    ***3. Join Condition:***
    
    - `*ON sales.product_id = menu.product_id`: This specifies the join condition. It matches rows where `product_id` in `sales` is equal to `product_id` in `menu`. This ensures we connect sales records to their corresponding menu item prices.*
    
    ***4. Grouping Data:***
    
    - `*GROUP BY sales.customer_id`: This groups the data by `customer_id`. The `SUM` function is applied within each group.*
    
    ***5. Ordering Results:***
    
    - `*ORDER BY sales.customer_id ASC`: Orders the final results by `customer_id` in ascending order.*
    
    ***In summary:***
    
    *This query joins `sales` and `menu` tables to associate sales with their corresponding menu item prices. It then calculates the total sales for each customer by summing the menu item prices within each customer group. Finally, it presents the results ordered by customer ID.*
    
2. **How many days has each customer visited the restaurant?**
    
    ```sql
    **SELECT
    customer_id,
    COUNT(DISTINCT order_date) AS visit_count
    FROM dannys_diner.sales
    GROUP BY customer_id;**
    ```
    
    **Output:**
    
    | customer_id | visit_count |
    | --- | --- |
    | A | 4 |
    | B | 6 |
    | C | 2 |
    
    **Here's a breakdown of the SQL query:**
    
    ***1. Selecting Columns:***
    
    - **`*customer_id`:** This selects the `customer_id` column from the `sales` table.*
    - **`*COUNT(DISTINCT order_date) AS visit_count`:** This counts the distinct `order_date` values for each `customer_id` and assigns the result to the alias `visit_count`.*
    
    ***2. Grouping Data:***
    
    - **`*GROUP BY customer_id`:** This groups the results by the `customer_id` column. This means that all rows with the same `customer_id` will be grouped together.*
    
    ***3. Counting Distinct Order Dates:***
    
    - **`*COUNT(DISTINCT order_date)`:** This counts the number of unique `order_date` values within each group. This effectively calculates the number of distinct visits for each customer.*
    
    ***In essence:***
    
    *This query calculates the number of distinct visits for each customer by counting the unique `order_date` values associated with each customer. The result is a table with two columns: `customer_id` and `visit_count`.*
    
3. **What was the first item from the menu purchased by each customer?**
    
    ```sql
    **WITH ordered_sales AS (
      SELECT 
        sales.customer_id, 
        sales.order_date, 
        menu.product_name,
        DENSE_RANK() OVER (
          PARTITION BY sales.customer_id 
          ORDER BY sales.order_date) AS rank
      FROM dannys_diner.sales
      INNER JOIN dannys_diner.menu
        ON sales.product_id = menu.product_id
    )
    
    SELECT 
      customer_id, 
      product_name
    FROM ordered_sales
    WHERE rank = 1
    GROUP BY customer_id, product_name;**
    ```
    
    **Output:**
    
    | customer_id | product_name |
    | --- | --- |
    | A | curry |
    | A | sushi |
    | B | curry |
    | C | ramen |
    |  |  |
    
     **Here's a breakdown of the SQL query:**
    
    ***1. Creating a Common Table Expression (CTE):***
    
    - **`*ordered_sales`**: This defines a temporary result set named `ordered_sales`.*
    
    ***2. Selecting Data for CTE:***
    
    - `*sales.customer_id, sales.order_date, menu.product_name`: These columns are selected from the `sales` and `menu` tables after joining them.*
    
    ***3. Window Function (DENSE_RANK):***
    
    - `*DENSE_RANK() OVER (PARTITION BY sales.customer_id ORDER BY sales.order_date) AS rank`:*
        - *This part uses the `DENSE_RANK` window function.*
        - `*PARTITION BY sales.customer_id`: This partitions the data by `customer_id`. It ensures ranking happens independently for each customer.*
        - `*ORDER BY sales.order_date`: This orders the data within each partition by `order_date` in ascending order.*
        - `*AS rank`: This assigns the rank value to the alias `rank`.*
    
    ***4. Joining Tables within CTE:***
    
    - *Similar to the previous query, `dannys_diner.sales` and `dannys_diner.menu` are joined on `sales.product_id = menu.product_id`.*
    
    ***5. Selecting from CTE:***
    
    - `*customer_id, product_name`: These columns are selected from the previously defined CTE `ordered_sales`.*
    
    ***6. Filtering by First Visit:***
    
    - `*WHERE rank = 1`: This filters the results to only include rows where `rank` is 1. This effectively selects the product name associated with the first order date (earliest visit) for each customer.*
    
    ***7. Grouping for Potential Duplicates:***
    
    - `*GROUP BY customer_id, product_name`: While filtering by `rank = 1` reduces duplicates, this grouping ensures no duplicates remain in the final result, even if multiple products were ordered on the first visit.*
    
    ***Overall, this query:***
    
    1. *Creates a temporary result set (`ordered_sales`) that assigns a rank to each order based on the customer and order date.*
    2. *Filters the ranked data to identify the product name associated with the first visit (lowest rank) for each customer.*
    3. *Groups the final results to ensure no duplicates exist, even if multiple products were ordered on the first visit.*
    
4. **What is the most purchased item on the menu and how many times was it purchased by all customers?**

```sql
**SELECT
menu.product_name,
COUNT(sales.product_id) AS most_purchased_item
FROM dannys_diner.sales
	INNER JOIN dannys_diner.menu
	ON sales.product_id = menu.product_id
GROUP BY menu.product_name
ORDER BY most_purchased_item DESC
LIMIT 1;**
```

Output:

| most_purchased | product_name |
| --- | --- |
| 8 | ramen |

**Here's a breakdown of the SQL query:**

***1. Selecting Data:***

- `*menu.product_name`: Selects the product name from the `menu` table.*
- `*COUNT(sales.product_id) AS most_purchased_item`: Counts the occurrences of `product_id` (representing individual product sales) from the `sales` table and assigns the count to the alias `most_purchased_item`.*

***2. Joining Tables:***

- `*FROM dannys_diner.sales`: Specifies the `sales` table as the source.*
- `*INNER JOIN dannys_diner.menu ON sales.product_id = menu.product_id`: Performs an inner join between `sales` and `menu` tables. This ensures we connect sales records to their corresponding product names.*

***3. Grouping Data by Product:***

- `*GROUP BY menu.product_name`: Groups the data based on the `product_name`. This allows us to count the total sales for each unique product.*

***4. Ordering by Sales Count:***

- `*ORDER BY most_purchased_item DESC`: Orders the results in descending order based on the `most_purchased_item` count. This places the most frequently purchased product at the top.*

***5. Limiting the Result:***

- `*LIMIT 1`: This limits the result set to only the top row (the product with the highest `most_purchased_item` count).*

***In essence:***

*This query joins the `sales` and `menu` tables to associate sales with product names. It then counts the occurrences of each product and groups them by name. Finally, it sorts the results based on the sales count and retrieves only the product with the highest count (the most purchased item).*
